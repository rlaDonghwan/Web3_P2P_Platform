<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>결제 페이지</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.5.2/dist/web3.min.js"></script>
    <link rel="stylesheet" th:href="@{/css/sendEther.css}">
    <link rel="stylesheet" th:href="@{/css/style.css}">
</head>
<body>
<div th:insert="~{nav.html}" class="fixed-top"></div>
<div th:insert="~{popup.html}"></div>

<script th:src="@{/js/login.js}"></script>
<div class="d-flex justify-content-center align-items-center vh-100" style="padding-top: 80px;">
    <div id="etherForm">
        <button type="button" id="connectButton" onclick="connectMetaMask()" class="btn btn-primary mb-3">메타마스크 연결</button>

        <label for="fromAddress">보내는 사람:</label>
        <input type="text" id="fromAddress" name="fromAddress" readonly>

        <label for="toAddress">받는 사람:</label>
        <input type="text" id="toAddress" name="toAddress" required>

        <label for="amount">수량(이더리움):</label>
        <input type="text" id="amount" name="amount" required>

        <button type="button" onclick="sendEther()" class="btn btn-primary mt-3">송금</button>
        <p id="status"></p>
    </div>
</div>

<script>
    // URL에서 쿼리 파라미터 가져오기 함수
    function getQueryParameter(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
    }

    // 초기화 - URL에서 전달된 이더리움 금액을 amount 필드에 설정
    document.getElementById("amount").value = getQueryParameter('ethPrice');

    // 수량 확인 및 예약 요청 함수
    async function checkAndReserveQuantity() {
        const itemId = getQueryParameter('itemId'); // URL에서 itemId를 가져옴
        if (!itemId) {
            alert("상품 ID가 필요합니다.");
            return false;
        }

        const response = await fetch(`/api/checkQuantity`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ itemId })
        });

        const result = await response.text();
        if (result === "Insufficient quantity") {
            alert("죄송합니다, 상품의 수량이 부족합니다.");
            return false;
        }
        return true; // 수량이 충분하면 송금 진행
    }

    async function connectMetaMask() {
        if (typeof window.ethereum !== 'undefined') {
            try {
                const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                document.getElementById('fromAddress').value = accounts[0];
                document.getElementById('status').innerHTML = "MetaMask connected!";
            } catch (error) {
                document.getElementById('status').innerHTML = `Error: ${error.message}`;
                document.getElementById('status').classList.add('error');
            }
        } else {
            alert("MetaMask not installed");
        }
    }

    // 트랜잭션 상태를 확인하는 함수
    async function checkTransactionStatus(txHash) {
        const web3 = new Web3(window.ethereum);
        while (true) {
            const receipt = await web3.eth.getTransactionReceipt(txHash);
            if (receipt) {
                return receipt; // 트랜잭션 상태 반환
            }
            await new Promise(resolve => setTimeout(resolve, 1000)); // 1초 대기 후 재확인
        }
    }

    // MetaMask와의 송금 트랜잭션 진행 함수
    async function sendEther() {
        const canProceed = await checkAndReserveQuantity();
        if (!canProceed) return;

        const fromAddress = document.getElementById("fromAddress").value;
        const toAddress = document.getElementById("toAddress").value;
        const amount = document.getElementById("amount").value;

        if (!fromAddress || !toAddress || !amount) {
            document.getElementById("status").innerHTML = "모든 필드를 채워 주세요";
            document.getElementById('status').classList.add('error');
            return;
        }

        if (typeof window.ethereum !== 'undefined') {
            try {
                const web3 = new Web3(window.ethereum);
                const transactionParameters = {
                    to: toAddress,
                    from: fromAddress,
                    value: web3.utils.toHex(web3.utils.toWei(amount, 'ether'))
                };

                ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [transactionParameters],
                })
                    .then(async (txHash) => {
                        document.getElementById("status").innerHTML = `Transaction Hash: ${txHash}`;
                        const transactionReceipt = await checkTransactionStatus(txHash);

                        if (transactionReceipt && transactionReceipt.status) {
                            alert("송금이 완료되었습니다!");
                            await saveOrder(); // 결제 내역 저장
                        } else {
                            alert("트랜잭션이 실패했습니다.");
                        }
                    })
                    .catch((error) => {
                        console.log(error);
                        document.getElementById("status").innerHTML = `Error: ${error.message}`;
                        document.getElementById('status').classList.add('error');
                    });
            } catch (error) {
                console.log(error);
                document.getElementById("status").innerHTML = `Error: ${error.message}`;
                document.getElementById('status').classList.add('error');
            }
        } else {
            document.getElementById("status").innerHTML = "MetaMask가 설치되어 있지 않습니다.";
            document.getElementById('status').classList.add('error');
        }
    }

    // 결제 내역을 서버에 저장하는 함수
    async function saveOrder() {
        const userId = getUserId();  // 여기서 getUserId 함수 호출
        const itemId = getQueryParameter('itemId');
        const quantity = Number(document.getElementById("amount").value);
        const buyerName = getQueryParameter('buyerName');
        const buyerAddress = getQueryParameter('buyerAddress');
        const buyerContact = getQueryParameter('buyerContact');

        if (!userId) {
            return;  // userId가 없으면 함수 종료
        }

        try {
            const response = await fetch(`/api/process`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ userId, itemId, quantity, buyerName, buyerAddress, buyerContact })
            });

            if (response.ok) {
                const result = await response.json();
                if (result.message === "Order saved successfully") {
                    alert("주문이 성공적으로 저장되었습니다.");
                    window.location.href = "/home";
                } else {
                    console.error("서버 에러 메시지:", result);
                    alert("에러: " + result.error);
                }
            } else {
                const errorDetails = await response.json();
                console.error("서버 에러 응답:", errorDetails);
                alert(`서버 오류 발생: ${errorDetails.error || "상세 정보를 확인하세요."}\n${errorDetails.details}`);
            }
        } catch (error) {
            console.error("요청 중 네트워크 에러 발생:", error);
            alert("네트워크 오류가 발생했습니다.");
        }
    }

    // 서버에서 글쓴이의 계좌 주소 가져와서 toAddress 필드에 자동 입력
    async function getAuthorAccount() {
        const itemId = getQueryParameter('itemId');
        if (!itemId) return;

        try {
            const response = await fetch(`/api/getAuthorAccount/${itemId}`);
            const data = await response.json();

            if (response.ok && data.account) {
                document.getElementById("toAddress").value = data.account;
            } else {
                console.error("글쓴이 계좌 정보를 가져오는 데 실패했습니다.");
            }
        } catch (error) {
            console.error("요청 중 네트워크 에러 발생:", error);
        }
    }

    // 페이지 로드 시 글쓴이 계좌 자동 입력
    document.addEventListener("DOMContentLoaded", () => {
        getAuthorAccount();
    });

    function getUserId() {
        const userId = sessionStorage.getItem("userId");
        if (!userId) {
            alert("로그인 정보가 필요합니다. 다시 로그인해주세요.");
        }
        return userId;
    }
</script>
</body>
</html>